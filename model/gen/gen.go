//go:build ignore

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io"
	"log"
	"os"
	"reflect"
	"strings"
)

type ConfigField struct {
	Name     string
	JSONName string
}

var structName string

func main() {
	flag.StringVar(&structName, "type", "AgentConfig", "Config Type")
	flag.Parse()

	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, "config.go", nil, 0)
	if err != nil {
		log.Fatalf("parser.ParseFile: %v", err)
	}

	cf := Parse(f)
	switchStmt := MakeStmt(cf)

	buf, err := Print(switchStmt)
	if err != nil {
		log.Fatalf("Print: %v", err)
	}

	file, err := os.Create("zconfig.go")
	if err != nil {
		log.Fatalf("os.Create: %v", err)
	}
	defer file.Close()

	fmt.Fprintf(file, "// Code generated by github.com/nezhahq/agent/model/gen. DO NOT EDIT.\n")
	fmt.Fprintf(file, "\n")

	if _, err := file.ReadFrom(buf); err != nil {
		log.Fatalf("(*os.File).ReadFrom: %v", err)
	}
}

func Parse(f *ast.File) []*ConfigField {
	var cf []*ConfigField

	ast.Inspect(f, func(n ast.Node) bool {
		switch t := n.(type) {
		case *ast.TypeSpec:
			if t.Name.Name != structName {
				return false
			}
			switch s := t.Type.(type) {
			case *ast.StructType:
				for _, field := range s.Fields.List {
					var fieldName string
					var tagValue string

					fieldName = field.Names[0].Name
					if field.Tag == nil {
						return false
					}

					tag, ok := reflect.StructTag(field.Tag.Value[1 : len(field.Tag.Value)-1]).Lookup("json")
					if !ok {
						return false
					}

					tagValue = strings.SplitN(tag, ",", 2)[0]
					if tagValue == "-" {
						return false
					}

					cf = append(cf, &ConfigField{
						Name:     fieldName,
						JSONName: tagValue,
					})
				}
			}
		}
		return true
	})

	return cf
}

func MakeStmt(cf []*ConfigField) *ast.SwitchStmt {
	var cases []ast.Stmt
	for _, f := range cf {
		stmt := &ast.CaseClause{
			List: []ast.Expr{
				&ast.BasicLit{
					Kind:  token.STRING,
					Value: fmt.Sprintf(`"%s"`, f.JSONName),
				},
			},
			Body: []ast.Stmt{
				&ast.AssignStmt{
					Lhs: []ast.Expr{
						&ast.SelectorExpr{
							X:   ast.NewIdent("c"),
							Sel: ast.NewIdent(f.Name),
						},
					},
					Tok: token.ASSIGN,
					Rhs: []ast.Expr{
						&ast.SelectorExpr{
							X:   ast.NewIdent("v"),
							Sel: ast.NewIdent(f.Name),
						},
					},
				},
			},
		}
		cases = append(cases, stmt)
	}

	cases = append(cases, &ast.CaseClause{
		List: nil,
		Body: []ast.Stmt{
			&ast.ReturnStmt{
				Results: []ast.Expr{
					&ast.CallExpr{
						Fun: ast.NewIdent("errors.New"),
						Args: []ast.Expr{
							&ast.BasicLit{
								Kind:  token.STRING,
								Value: fmt.Sprintf(`"%s"`, "field name is not valid"),
							},
						},
					},
				},
			},
		},
	})

	return &ast.SwitchStmt{
		Switch: token.NoPos,
		Tag:    ast.NewIdent("field"),
		Body: &ast.BlockStmt{
			List: cases,
		},
	}
}

func Print(stmt *ast.SwitchStmt) (io.Reader, error) {
	fset := token.NewFileSet()
	funcDecl := &ast.FuncDecl{
		Recv: &ast.FieldList{
			List: []*ast.Field{
				{
					Names: []*ast.Ident{
						ast.NewIdent("c"),
					},
					Type: &ast.StarExpr{
						X: ast.NewIdent(structName),
					},
				},
			},
		},
		Name: ast.NewIdent("Apply"),
		Type: &ast.FuncType{
			Params: &ast.FieldList{
				List: []*ast.Field{
					{
						Names: []*ast.Ident{
							ast.NewIdent("field"),
						},
						Type: ast.NewIdent("string"),
					},
					{
						Names: []*ast.Ident{
							ast.NewIdent("v"),
						},
						Type: &ast.StarExpr{
							X: ast.NewIdent(structName),
						},
					},
				},
			},
			Results: &ast.FieldList{
				List: []*ast.Field{
					{
						Names: nil,
						Type:  ast.NewIdent("error"),
					},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				stmt,
				&ast.ReturnStmt{
					Results: []ast.Expr{
						ast.NewIdent("nil"),
					},
				},
			},
		},
	}

	astFile := &ast.File{
		Name: ast.NewIdent("model"),
		Decls: []ast.Decl{
			&ast.GenDecl{
				Tok: token.IMPORT,
				Specs: []ast.Spec{
					&ast.ImportSpec{
						Path: &ast.BasicLit{
							Kind:  token.STRING,
							Value: `"errors"`,
						},
					},
				},
			},
			funcDecl,
		},
	}

	var buf bytes.Buffer
	err := format.Node(&buf, fset, astFile)
	if err != nil {
		return nil, err
	}

	return &buf, nil
}
