//go:build ignore

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io"
	"log"
	"os"
	"reflect"
	"strings"
)

type ConfigField struct {
	Name     string
	JSONName string
	Type     string
}

var structName string

func main() {
	flag.StringVar(&structName, "type", "AgentConfig", "Config Type")
	flag.Parse()

	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, "config.go", nil, 0)
	if err != nil {
		log.Fatalf("parser.ParseFile: %v", err)
	}

	cf := Parse(f)
	switchStmt := MakeStmt(cf)

	buf, err := Print(switchStmt)
	if err != nil {
		log.Fatalf("Print: %v", err)
	}

	file, err := os.Create("zconfig.go")
	if err != nil {
		log.Fatalf("os.Create: %v", err)
	}
	defer file.Close()

	fmt.Fprintf(file, "// Code generated by agent/model/gen. DO NOT EDIT.\n")
	fmt.Fprintf(file, "\n")

	if _, err := file.ReadFrom(buf); err != nil {
		log.Fatalf("(*os.File).ReadFrom: %v", err)
	}
}

func Parse(f *ast.File) []*ConfigField {
	var cf []*ConfigField

	ast.Inspect(f, func(n ast.Node) bool {
		switch t := n.(type) {
		case *ast.TypeSpec:
			if t.Name.Name != structName {
				return false
			}
			switch s := t.Type.(type) {
			case *ast.StructType:
				for _, field := range s.Fields.List {
					var fieldName string
					var tagValue string
					var typ string

					switch ft := field.Type.(type) {
					case *ast.Ident:
						typ = ft.Name
					case *ast.ArrayType:
						typ = "array"
					case *ast.MapType:
						typ = "map"
					default:
						return false
					}

					fieldName = field.Names[0].Name
					if field.Tag == nil {
						return false
					}

					tag, ok := reflect.StructTag(field.Tag.Value[1 : len(field.Tag.Value)-1]).Lookup("json")
					if !ok {
						return false
					}

					tagValue = strings.SplitN(tag, ",", 2)[0]
					cf = append(cf, &ConfigField{
						Name:     fieldName,
						JSONName: tagValue,
						Type:     typ,
					})
				}
			}
		}
		return true
	})

	return cf
}

func MakeStmt(cf []*ConfigField) *ast.SwitchStmt {
	var cases []ast.Stmt
	for _, f := range cf {
		switch f.Type {
		case "map", "array":
			stmt := &ast.CaseClause{
				List: []ast.Expr{
					&ast.BasicLit{
						Kind:  token.STRING,
						Value: fmt.Sprintf(`"%s"`, f.JSONName),
					},
				},
				Body: []ast.Stmt{
					&ast.ReturnStmt{
						Results: []ast.Expr{
							&ast.CallExpr{
								Fun: ast.NewIdent("util.Json.Unmarshal"),
								Args: []ast.Expr{
									&ast.CallExpr{
										Fun: ast.NewIdent("[]byte"),
										Args: []ast.Expr{
											&ast.SelectorExpr{
												X:   ast.NewIdent("v"),
												Sel: ast.NewIdent("Raw"),
											},
										},
									},
									&ast.UnaryExpr{
										Op: token.AND,
										X: &ast.SelectorExpr{
											X:   ast.NewIdent("c"),
											Sel: ast.NewIdent(f.Name),
										},
									},
								},
							},
						},
					},
				},
			}
			cases = append(cases, stmt)
		default:
			stmt := &ast.CaseClause{
				List: []ast.Expr{
					&ast.BasicLit{
						Kind:  token.STRING,
						Value: fmt.Sprintf(`"%s"`, f.JSONName),
					},
				},
				Body: []ast.Stmt{
					&ast.AssignStmt{
						Lhs: []ast.Expr{
							&ast.SelectorExpr{
								X:   ast.NewIdent("c"),
								Sel: ast.NewIdent(f.Name),
							},
						},
						Tok: token.ASSIGN,
						Rhs: []ast.Expr{
							&ast.CallExpr{
								Fun: ast.NewIdent(f.Type),
								Args: []ast.Expr{
									&ast.CallExpr{
										Fun:  ast.NewIdent(fmt.Sprintf("v.%s", toGjsonMethod(f.Type))),
										Args: []ast.Expr{},
									},
								},
							},
						},
					},
				},
			}
			cases = append(cases, stmt)
		}
	}
	cases = append(cases, &ast.CaseClause{
		List: nil,
		Body: []ast.Stmt{
			&ast.ReturnStmt{
				Results: []ast.Expr{
					&ast.CallExpr{
						Fun: ast.NewIdent("errors.New"),
						Args: []ast.Expr{
							&ast.BasicLit{
								Kind:  token.STRING,
								Value: fmt.Sprintf(`"%s"`, "field name is not valid"),
							},
						},
					},
				},
			},
		},
	})

	return &ast.SwitchStmt{
		Switch: token.NoPos,
		Tag:    ast.NewIdent("field"),
		Body: &ast.BlockStmt{
			List: cases,
		},
	}
}

func Print(stmt *ast.SwitchStmt) (io.Reader, error) {
	fset := token.NewFileSet()
	funcDecl := &ast.FuncDecl{
		Recv: &ast.FieldList{
			List: []*ast.Field{
				{
					Names: []*ast.Ident{
						ast.NewIdent("c"),
					},
					Type: &ast.StarExpr{
						X: ast.NewIdent(structName),
					},
				},
			},
		},
		Name: ast.NewIdent("Apply"),
		Type: &ast.FuncType{
			Params: &ast.FieldList{
				List: []*ast.Field{
					{
						Names: []*ast.Ident{
							ast.NewIdent("field"),
						},
						Type: ast.NewIdent("string"),
					},
					{
						Names: []*ast.Ident{
							ast.NewIdent("v"),
						},
						Type: &ast.StarExpr{
							X: ast.NewIdent("gjson.Result"),
						},
					},
				},
			},
			Results: &ast.FieldList{
				List: []*ast.Field{
					{
						Names: nil,
						Type:  ast.NewIdent("error"),
					},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				stmt,
				&ast.ReturnStmt{
					Results: []ast.Expr{
						ast.NewIdent("nil"),
					},
				},
			},
		},
	}

	astFile := &ast.File{
		Name: ast.NewIdent("model"),
		Decls: []ast.Decl{
			&ast.GenDecl{
				Tok: token.IMPORT,
				Specs: []ast.Spec{
					&ast.ImportSpec{
						Path: &ast.BasicLit{
							Kind:  token.STRING,
							Value: `"errors"`,
						},
					},
					&ast.ImportSpec{
						Path: &ast.BasicLit{
							Kind:  token.STRING,
							Value: `"github.com/tidwall/gjson"`,
						},
					},
					&ast.ImportSpec{
						Path: &ast.BasicLit{
							Kind:  token.STRING,
							Value: `"github.com/nezhahq/agent/pkg/util"`,
						},
					},
				},
			},
			funcDecl,
		},
	}

	var buf bytes.Buffer
	err := format.Node(&buf, fset, astFile)
	if err != nil {
		return nil, err
	}

	return &buf, nil
}

func toGjsonMethod(typ string) string {
	switch typ {
	case "string":
		return "String"
	case "uint", "uint32", "uint64":
		return "Uint"
	case "int", "int32", "int64":
		return "Int"
	case "bool":
		return "Bool"
	default:
		return ""
	}
}
